use std::sync::Mutex;
use std::sync::atomic::AtomicBool;

use once_cell::unsync::OnceCell;

use wasm_bindgen::Clamped;
use wasm_bindgen::JsCast;
use wasm_bindgen::prelude::*;
use web_sys::Document;
use web_sys::EventTarget;
use web_sys::HtmlElement;
use web_sys::ImageData;
use web_sys::{CanvasRenderingContext2d, HtmlCanvasElement, MouseEvent};

const BOARD_WIDTH: u16 = 800;
const BOARD_HEIGHT: u16 = 600;

const DETECTOR_SIZE_RAD: u16 = 10;
const DETECTOR_RANGE_RAD: u16 = 50;

#[derive(Debug)]
struct GameState {
    // the canvas in html
    canvas: HtmlCanvasElement,
    // javascript closure that draw in the frame
    draw_handle: JsValue,
    // javascript closure that is enabled/disabled on click
    pointer_move_handle: JsValue,
    // detector currently selected
    detector_selected: Mutex<Option<DetectorIdx>>,
    // if the detector can review new pixels
    safe_mode: AtomicBool,
    // game state
    grid: Mutex<Option<GameGrid>>,
    // the unprocessed movement generated by the mouse
    movement_queue: Mutex<Vec<Movement>>,
}

#[derive(Debug, Clone)]
struct GameGrid {
    width: usize,
    height: usize,
    detectors: Vec<Detector>,
    grid: Vec<PixelState>,
}

#[derive(Debug, Clone, Copy)]
struct PixelState {
    have_bomb: bool,
    hidden: bool,
}

#[derive(Debug, Clone, Copy)]
struct DetectorIdx(usize);

#[derive(Debug, Clone, Copy)]
struct Detector {
    x: usize,
    y: usize,
    bombs: usize,
}

#[derive(Debug, Clone, Copy)]
struct Movement {
    detector: DetectorIdx,
    x: i32,
    y: i32,
}

impl GameState {
    fn reset(&self) {
        *self.detector_selected.lock().unwrap() = None;
        *self.grid.lock().unwrap() =
            Some(GameGrid::new(BOARD_WIDTH.into(), BOARD_HEIGHT.into()));
        self.movement_queue.lock().unwrap().clear();
    }
}

impl GameGrid {
    fn new(width: usize, height: usize) -> Self {
        let mut slf = Self {
            height,
            width,
            grid: vec![
                PixelState {
                    have_bomb: false,
                    hidden: true,
                };
                height * width
            ],
            detectors: vec![],
        };

        slf.spawn_detector();
        slf.detector_reveal_range(width / 2, height / 2);
        slf.put_bombs(50);
        slf
    }

    fn spawn_detector(&mut self) {
        let detector_default = Detector {
            x: self.width / 2,
            y: self.height / 2,
            bombs: 0,
        };
        self.detectors.push(detector_default);
    }

    fn round_area(
        &self,
        x: usize,
        y: usize,
        radius: usize,
    ) -> impl Iterator<Item = (usize, usize)> + 'static {
        // TODO don't do it the dumb way
        let x_start = x.saturating_sub(radius.into());
        let x_end = x
            .saturating_add(radius.into())
            .min((BOARD_WIDTH - 1).into());
        let y_start = y.saturating_sub(radius.into());
        let y_end = y
            .saturating_add(radius.into())
            .min((BOARD_HEIGHT - 1).into());
        (x_start..=x_end).flat_map(move |x_current| {
            (y_start..=y_end).filter_map(move |y_current| {
                let x_abs = x.abs_diff(x_current);
                let y_abs = y.abs_diff(y_current);
                let distance = usize::isqrt(x_abs.pow(2) + y_abs.pow(2));
                // if inside the area, show the pixel
                (distance < radius.into()).then_some((x_current, y_current))
            })
        })
    }

    fn detector_touch_hidden(&self, x: usize, y: usize) -> bool {
        // TODO don't do it the dumb way
        self.round_area(x, y, DETECTOR_SIZE_RAD.into())
            .any(|(x, y)| self.pixel_at(x, y).hidden)
    }

    fn detector_reveal_area(&mut self, x: usize, y: usize) {
        // TODO don't do it the dumb way
        self.round_area(x, y, DETECTOR_SIZE_RAD.into())
            .for_each(|(x, y)| self.pixel_at_mut(x, y).hidden = false)
    }

    fn detector_reveal_range(&mut self, x: usize, y: usize) {
        // TODO don't do it the dumb way
        self.round_area(x, y, DETECTOR_RANGE_RAD.into())
            .for_each(|(x, y)| self.pixel_at_mut(x, y).hidden = false)
    }

    fn detector_calculate_bombs(&self, x: usize, y: usize) -> usize {
        self.round_area(x, y, DETECTOR_RANGE_RAD.into())
            .filter(|&(x, y)| self.pixel_at(x, y).have_bomb)
            .count()
    }

    fn put_bombs(&mut self, num: usize) {
        // TODO double check there available spaces!
        let mut remaining = num;
        // TODO make it deterministic! 128 to avoid infinity loop
        for _ in 0..num * 128 {
            if remaining == 0 {
                break;
            }
            let rand_x = js_sys::Math::random() * f64::from(BOARD_WIDTH - 1);
            let rand_y = js_sys::Math::random() * f64::from(BOARD_HEIGHT - 1);
            let pixel = self.pixel_at_mut(rand_x as _, rand_y as _);
            if pixel.hidden && !pixel.have_bomb {
                pixel.have_bomb = true;
                remaining -= 1;
            }
        }
    }

    fn pixel_at(&self, x: usize, y: usize) -> PixelState {
        let idx = (y * usize::from(BOARD_WIDTH)) + x;
        self.grid[idx]
    }

    fn pixel_at_mut(&mut self, x: usize, y: usize) -> &mut PixelState {
        let idx = (y * usize::from(BOARD_WIDTH)) + x;
        &mut self.grid[idx]
    }
}

impl GameState {
    fn canvas_2d(&self) -> CanvasRenderingContext2d {
        self.canvas
            .get_context("2d")
            .unwrap()
            .expect("2d context not available")
            .dyn_into::<CanvasRenderingContext2d>()
            .unwrap()
    }

    fn get_detector_at(&self, x: usize, y: usize) -> Option<DetectorIdx> {
        let grid_lock = self.grid.lock().unwrap();
        grid_lock
            .as_ref()?
            .detectors
            .iter()
            .position(|grid| {
                let x_abs = grid.x.abs_diff(x);
                let y_abs = grid.y.abs_diff(y);
                // thanks Pythagoras : a^2 + b^2 = c^2
                let distance = usize::isqrt(x_abs.pow(2) + y_abs.pow(2));
                distance < usize::from(DETECTOR_SIZE_RAD)
            })
            .map(|idx| DetectorIdx(idx))
    }
}

thread_local! {
    // store a single context for convenience
    static CTX: OnceCell<GameState> = OnceCell::new();
}

#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    // better error messages on panic
    console_error_panic_hook::set_once();

    let window = web_sys::window().expect("should have a window");
    let document = window.document().expect("should have a document");

    // expects an element with id="canvas" in the page
    let canvas = document
        .get_element_by_id("canvas")
        .expect("canvas element not found")
        .dyn_into::<HtmlCanvasElement>()?;

    let pointermove_closure = Closure::<
        dyn Fn(MouseEvent) -> Result<(), JsValue>,
    >::new(detector_move)
    .into_js_value();

    let draw_closure =
        Closure::<dyn Fn() -> Result<(), JsValue>>::new(drawn).into_js_value();

    CTX.with(|c| {
        c.set(GameState {
            canvas: canvas.clone(),
            draw_handle: draw_closure.clone(),
            pointer_move_handle: pointermove_closure.clone(),
            grid: Mutex::new(Some(GameGrid::new(
                BOARD_WIDTH.into(),
                BOARD_HEIGHT.into(),
            ))),
            safe_mode: true.into(),
            movement_queue: Mutex::new(vec![]),
            detector_selected: Mutex::new(None),
        })
        .expect("init called multiple times")
    });

    canvas.set_width(BOARD_WIDTH.into());
    canvas.set_height(BOARD_HEIGHT.into());

    let canvas = canvas.dyn_into::<web_sys::EventTarget>()?;

    let pointerdown_closure = Closure::<
        dyn Fn(MouseEvent) -> Result<(), JsValue>,
    >::new(detector_select)
    .into_js_value();
    canvas.add_event_listener_with_callback(
        "pointerdown",
        pointerdown_closure.dyn_ref().unwrap(),
    )?;

    let pointerup_closure =
        Closure::<dyn Fn(MouseEvent) -> Result<(), JsValue>>::new(
            detector_unselect,
        )
        .into_js_value();
    canvas.add_event_listener_with_callback(
        "pointerup",
        pointerup_closure.dyn_ref().unwrap(),
    )?;

    let pointerleave_closure = Closure::<
        dyn Fn(MouseEvent) -> Result<(), JsValue>,
    >::new(detector_unselect)
    .into_js_value();
    canvas.add_event_listener_with_callback(
        "pointerleave",
        pointerleave_closure.dyn_ref().unwrap(),
    )?;

    request_redrawn()?;
    Ok(())
}

#[wasm_bindgen]
pub fn toggle_safe_mode() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        let mode = !ctx
            .safe_mode
            .fetch_not(std::sync::atomic::Ordering::Relaxed);
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let score = document
            .get_element_by_id("safe-mode")
            .unwrap()
            .dyn_into::<HtmlElement>()?;
        score.set_text_content(Some(&format!(
            "Safe Mode: {}",
            if mode { "on" } else { "off" }
        )));
        Ok(())
    })
}

#[wasm_bindgen]
pub fn spawn_detector() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        ctx.grid.lock().unwrap().as_mut().unwrap().spawn_detector();
        request_redrawn()?;
        Ok(())
    })
}

#[wasm_bindgen]
pub fn despawn_detector() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        ctx.grid.lock().unwrap().as_mut().unwrap().detectors.pop();
        request_redrawn()?;
        Ok(())
    })
}

fn request_redrawn() -> Result<(), JsValue> {
    let window = web_sys::window().unwrap();
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        window.request_animation_frame(ctx.draw_handle.dyn_ref().unwrap())?;
        Ok(())
    })
}

fn drawn() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        process_movement(ctx)?;
        draw_grid(ctx)?;
        draw_detectors(ctx)?;
        show_score(ctx)?;
        Ok(())
    })
}

fn process_movement(ctx: &GameState) -> Result<(), JsValue> {
    // take all the elements from movement and process then
    let mut movements_lock = ctx.movement_queue.lock().unwrap();
    let mut movements = movements_lock.drain(..);
    let mut grid = ctx.grid.lock().unwrap();
    // TODO
    let grid = grid.as_mut().expect("Game not initialized");
    loop {
        let Some(Movement { detector, x, y }) = movements.next() else {
            break;
        };
        let current_detector = &grid.detectors[detector.0];
        let new_x = current_detector
            .x
            .saturating_add_signed(x.try_into().unwrap())
            .min((BOARD_WIDTH - 1).into());
        let new_y = current_detector
            .y
            .saturating_add_signed(y.try_into().unwrap())
            .min((BOARD_HEIGHT - 1).into());

        // if in safe mode and touching a new pixel, cancel that movement,
        // the next ones, also stop listning to movements
        if ctx.safe_mode.load(std::sync::atomic::Ordering::Relaxed)
            && grid.detector_touch_hidden(new_x, new_y)
        {
            movements.for_each(|_| {});
            disable_mouse_move_listener()?;
            break;
        }

        let bombs = grid.detector_calculate_bombs(new_x, new_y);
        grid.detectors[detector.0] = Detector {
            x: new_x,
            y: new_y,
            bombs: bombs,
        };

        // TODO don't do it the dumb way assuming the movement is always small.
        if bombs == 0 {
            // if no bombs are detected, reveal the safe area.
            grid.detector_reveal_range(new_x, new_y);
        } else {
            grid.detector_reveal_area(new_x, new_y);
        }
    }
    Ok(())
}

fn draw_grid(ctx: &GameState) -> Result<(), JsValue> {
    let canvas = ctx.canvas_2d();
    let game_grid_lock = ctx.grid.lock().unwrap();
    let game_grid = game_grid_lock.as_ref().unwrap();
    let bg_pixels: Vec<u8> = game_grid
        .grid
        .iter()
        .flat_map(|pixel| match pixel {
            PixelState {
                have_bomb: true,
                hidden: false,
            } => [255, 0, 0, 255],
            PixelState {
                have_bomb: false,
                hidden: false,
            } => [255, 255, 255, 255],
            PixelState {
                have_bomb: _,
                hidden: true,
            } => [125, 125, 125, 255],
        })
        .collect();
    let bg = ImageData::new_with_u8_clamped_array_and_sh(
        Clamped(&bg_pixels),
        BOARD_WIDTH.into(),
        BOARD_HEIGHT.into(),
    )?;
    canvas.put_image_data(&bg, 0.0, 0.0)?;
    Ok(())
}

fn draw_detectors(ctx: &GameState) -> Result<(), JsValue> {
    // TODO initialize game somehow?
    let grid_lock = ctx.grid.lock().unwrap();
    let grid = grid_lock.as_ref().expect("Game not initialized");
    for detector in &grid.detectors {
        let canvas = ctx.canvas_2d();

        canvas.begin_path();
        canvas.arc(
            detector.x as f64,
            detector.y as f64,
            DETECTOR_SIZE_RAD.into(),
            0.0,
            std::f64::consts::TAU,
        )?;
        canvas.stroke();

        canvas.begin_path();
        canvas.arc(
            detector.x as f64,
            detector.y as f64,
            DETECTOR_RANGE_RAD.into(),
            0.0,
            std::f64::consts::TAU,
        )?;
        canvas.stroke();

        canvas.save();
        match detector.bombs {
            0 => canvas.set_fill_style_str("black"),
            1 => canvas.set_fill_style_str("orange"),
            2 => canvas.set_fill_style_str("red"),
            _ => canvas.set_fill_style_str("purple"),
        }
        canvas.set_text_align("center");
        canvas.set_text_baseline("middle");
        canvas.fill_text_with_max_width(
            &format!("{}", detector.bombs),
            detector.x as f64,
            detector.y as f64,
            (DETECTOR_SIZE_RAD * 2).into(),
        )?;
        canvas.restore();
    }
    Ok(())
}

fn show_score(ctx: &GameState) -> Result<(), JsValue> {
    let grid_lock = ctx.grid.lock().unwrap();
    // TODO
    let grid = grid_lock.as_ref().expect("Game not initialized");
    let revealed = grid.grid.iter().filter(|x| !x.hidden).count();
    let not_bombs = grid.grid.iter().filter(|x| !x.have_bomb).count();
    let percentage = ((revealed as f64 / not_bombs as f64) * 100.0) as u64;
    let bombs = grid
        .grid
        .iter()
        .filter(|x| !x.hidden && x.have_bomb)
        .count();

    let window = web_sys::window().expect("should have a window");
    let document = window.document().expect("should have a document");
    let score = document
        .get_element_by_id("score")
        .expect("canvas element not found")
        .dyn_into::<HtmlElement>()?;
    score.set_text_content(Some(&format!(
        "Bombs!: {bombs}, Revealed: {percentage}%"
    )));
    Ok(())
}

fn log(message: &str) {
    web_sys::console::log(&[&JsValue::from_str(message)].into_iter().collect());
}

fn add_onclick_element_by_id(
    document: &Document,
    name: &str,
    closure: impl Fn(MouseEvent) -> Result<(), JsValue> + 'static,
) -> Result<(), JsValue> {
    add_onclick(
        document
            .get_element_by_id(name)
            .expect("canvas element not found")
            .dyn_into::<web_sys::EventTarget>()?,
        closure,
    )
}

fn add_onclick(
    target: EventTarget,
    closure: impl Fn(MouseEvent) -> Result<(), JsValue> + 'static,
) -> Result<(), JsValue> {
    target.add_event_listener_with_callback(
        "click",
        Closure::<dyn Fn(MouseEvent) -> Result<(), JsValue>>::new(closure)
            .into_js_value()
            .dyn_ref()
            .expect("Wrong closure kind in add_onclick_element"),
    )
}

// Basic drawing functions exposed to JS
#[wasm_bindgen]
pub fn new_game() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = &c.get().unwrap();
        ctx.reset();
        request_redrawn()
    })
}

fn detector_select(event: MouseEvent) -> Result<(), JsValue> {
    let x: usize = event.offset_x().try_into().unwrap();
    let y: usize = event.offset_y().try_into().unwrap();
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        // only capture the mouse movements if a detector was selected
        if let Some(detector_idx) = ctx.get_detector_at(x, y) {
            *ctx.detector_selected.lock().unwrap() = Some(detector_idx);
            enable_mouse_move_listener()?;
        }
        Ok(())
    })
}

fn detector_unselect(_event: MouseEvent) -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        let mut detector = ctx.detector_selected.lock().unwrap();
        *detector = None;
        disable_mouse_move_listener()?;
        Ok(())
    })
}

fn detector_move(event: MouseEvent) -> Result<(), JsValue> {
    let x = event.movement_x();
    let y = event.movement_y();
    // This should never happen, ignore it just in case
    if x == 0 && y == 0 {
        return Ok(());
    }
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        let Some(detector) = *ctx.detector_selected.lock().unwrap() else {
            panic!("Invalid state, mouse movement captured, but no detector selected");
        };
        ctx.movement_queue.lock().unwrap().push(Movement { detector, x, y });
        request_redrawn()?;
        Ok(())
    })
}

fn enable_mouse_move_listener() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        ctx.canvas
            .clone()
            .dyn_into::<web_sys::EventTarget>()
            .expect("dyn_into")
            .add_event_listener_with_callback(
                "pointermove",
                ctx.pointer_move_handle.dyn_ref().unwrap(),
            )
            .expect("add_event");
        Ok(())
    })
}

fn disable_mouse_move_listener() -> Result<(), JsValue> {
    CTX.with(|c| {
        let ctx = c.get().unwrap();
        ctx.canvas
            .clone()
            .dyn_into::<web_sys::EventTarget>()?
            .remove_event_listener_with_callback(
                "pointermove",
                ctx.pointer_move_handle.dyn_ref().unwrap(),
            )
    })
}
